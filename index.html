<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨åŠ›æ€»æˆå°æ¶è¯•éªŒæ•°æ®åˆ†æå¹³å°</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* å·¦ä¾§æ ï¼šåˆ—ååˆ—è¡¨ */
        .sidebar {
            width: 300px;
            background: white;
            border-right: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom: 2px solid #667eea;
        }

        .sidebar-header h2 {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .file-selector {
            margin-top: 10px;
        }

        .file-selector select {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 0.9em;
        }

        .file-selector select option {
            background: #667eea;
            color: white;
        }

        .column-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .column-item {
            padding: 12px 15px;
            margin: 5px 0;
            background: #f8f9fa;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .column-item:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateX(5px);
        }

        .column-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            font-weight: 600;
        }

        .column-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
            color: #1976d2;
        }

        .column-item.active.selected {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
            color: white;
        }

        /* å³ä¾§ä¸»å†…å®¹åŒº */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #f5f7fa;
        }

        .content-header {
            padding: 20px 30px;
            background: white;
            border-bottom: 2px solid #e0e0e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .content-header h2 {
            color: #667eea;
            font-size: 1.5em;
            margin: 0;
            font-weight: 700;
        }

        .content-body {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #f5f7fa;
        }

        /* æ•°æ®åˆ†æåŒºåŸŸ */
        .analysis-section {
            margin-bottom: 30px;
        }

        .analysis-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .stat-card .value {
            font-size: 1.8em;
            font-weight: bold;
        }

        /* å›¾è¡¨åŒºåŸŸ */
        .chart-section {
            margin-top: 30px;
        }

        .charts-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-container {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.08);
            position: relative;
            transition: box-shadow 0.3s;
        }

        .chart-container:hover {
            box-shadow: 0 5px 20px rgba(0,0,0,0.12);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
            padding: 15px 20px;
            border-radius: 8px;
            margin: -20px -20px 20px -20px;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .chart-header h4 {
            color: #667eea;
            font-size: 1.2em;
            font-weight: 700;
            margin: 0;
        }

        .chart-close {
            background: #f0f0f0;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2em;
            color: #666;
            transition: all 0.3s;
        }

        .chart-close:hover {
            background: #e0e0e0;
            color: #c33;
        }

        /* å›¾è¡¨æ§åˆ¶é¢æ¿æ ·å¼ */
        .chart-controls {
            background: #f8f9fa;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
        }

        .chart-controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .axis-control-group {
            display: flex;
            align-items: center;
        }

        .axis-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .axis-control label {
            font-size: 14px;
            font-weight: 600;
            color: #555;
            min-width: 60px;
        }

        .axis-input {
            width: 100px;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            transition: border-color 0.3s;
        }

        .axis-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        .axis-separator {
            color: #666;
            font-weight: bold;
        }

        .axis-button {
            padding: 8px 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .axis-button:hover {
            background: #5568d3;
        }

        .axis-select-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .axis-select-group label {
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }

        .axis-select {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .axis-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        .chart-wrapper {
            position: relative;
            width: 100%;
        }

        .chart-canvas {
            width: 100%;
            height: 500px;
            display: block;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .error {
            padding: 20px;
            background: #fee;
            color: #c33;
            border-radius: 5px;
            margin: 20px 0;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¦ä¾§æ ï¼šåˆ—ååˆ—è¡¨ -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>ğŸ“Š æ•°æ®åˆ—å</h2>
                <div class="file-selector">
                    <input type="file" id="fileInput" accept=".dat,.csv,.txt,.xlsx" style="display: none;" onchange="handleFileSelect(event)">
                    <button onclick="document.getElementById('fileInput').click()" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; cursor: pointer; font-size: 0.9em;">
                        é€‰æ‹©æ–‡ä»¶
                    </button>
                    <div id="fileName" style="margin-top: 10px; font-size: 0.85em; opacity: 0.9;"></div>
                    <!-- åˆ—åè¡Œå·è®¾ç½® -->
                        <div style="margin-top: 15px;">
                            <label style="font-size: 0.85em; opacity: 0.9; margin-right: 5px;">åˆ—åè¡Œå·:</label>
                            <input type="number" id="headerRowInput" value="1" min="1" style="width: 60px; padding: 5px; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; background: rgba(255,255,255,0.2); color: white; font-size: 0.85em;">
                            <button onclick="reloadFileData()" style="margin-left: 5px; padding: 5px 10px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; color: white; cursor: pointer; font-size: 0.85em;">
                                åº”ç”¨
                            </button>
                        </div>
                </div>
            </div>
            <div class="column-list" id="columnList">
                <div class="empty-state">
                    <h3>è¯·é€‰æ‹©æ–‡ä»¶</h3>
                    <p>é€‰æ‹©æ–‡ä»¶åï¼Œåˆ—åå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</p>
                </div>
            </div>
        </div>

        <!-- å³ä¾§ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <div class="content-header">
                <h2 id="selectedColumnName">è¯·ä»å·¦ä¾§é€‰æ‹©è¦åˆ†æçš„åˆ—</h2>
            </div>
            <div class="content-body" id="contentBody">
                <div class="empty-state">
                    <h3>ğŸ‘ˆ é€‰æ‹©æ•°æ®åˆ—</h3>
                    <p>ä»å·¦ä¾§åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªåˆ—åï¼ŒæŸ¥çœ‹è¯¥åˆ—çš„æ•°æ®åˆ†æå’Œå¯è§†åŒ–å›¾è¡¨</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let parsedData = null;
        let columnNames = [];
        let currentSelectedColumn = null;
        let chartCounter = 0;
        let activeCharts = []; // å­˜å‚¨æ´»åŠ¨çš„å›¾è¡¨ä¿¡æ¯

        // é¢„è®¾é¢œè‰²åˆ—è¡¨ï¼Œç”¨äºåŒºåˆ†ä¸åŒçš„æ•°æ®çº¿
        const lineColors = [
            '#0066cc', '#ff6600', '#009900', '#cc0066', '#6600cc',
            '#00cccc', '#ffcc00', '#cc6600', '#990099', '#006666'
        ];

        let currentFile = null;

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            currentFile = file;
            document.getElementById('fileName').textContent = file.name;

            loadFile(file);
        }

        // é‡æ–°åŠ è½½æ–‡ä»¶æ•°æ®ï¼ˆå½“ç”¨æˆ·ä¿®æ”¹åˆ—åè¡Œå·æ—¶ï¼‰
        function reloadFileData() {
            if (!currentFile) {
                alert('è¯·å…ˆé€‰æ‹©æ–‡ä»¶');
                return;
            }
            loadFile(currentFile);
        }

        // åŠ è½½æ–‡ä»¶
        function loadFile(file) {
            if (file.name.endsWith('.xlsx')) {
                // å¤„ç†.xlsxæ–‡ä»¶
                const reader = new FileReader();
                reader.onload = (e) => {
                    loadXlsxData(e.target.result, file.name);
                };
                reader.onerror = () => {
                    const columnList = document.getElementById('columnList');
                    columnList.innerHTML = '<div class="error">Excelæ–‡ä»¶è¯»å–å¤±è´¥</div>';
                };
                reader.readAsArrayBuffer(file);
            } else {
                // å¤„ç†æ–‡æœ¬æ–‡ä»¶ï¼ˆ.dat, .csv, .txtï¼‰
                const reader = new FileReader();
                reader.onload = (e) => {
                    loadFileData(e.target.result, file.name);
                };
                reader.onerror = () => {
                    const columnList = document.getElementById('columnList');
                    columnList.innerHTML = '<div class="error">æ–‡ä»¶è¯»å–å¤±è´¥</div>';
                };
                reader.readAsText(file, 'GBK'); // å°è¯•GBKç¼–ç 
            }
        }

        // åŠ è½½æ–‡æœ¬æ–‡ä»¶æ•°æ®
        function loadFileData(rawData, fileName) {
            const columnList = document.getElementById('columnList');
            columnList.innerHTML = '<div class="loading">æ­£åœ¨è§£ææ–‡ä»¶...<br><div id="parseProgress" style="margin-top: 10px; font-size: 14px; color: #666;">å‡†å¤‡è§£æ...</div></div>';

            // ä½¿ç”¨setTimeoutå°†è§£æä»»åŠ¡æ”¾å…¥äº‹ä»¶é˜Ÿåˆ—ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
            setTimeout(() => {
                try {
                    // ä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹å¼å¤„ç†æ–‡ä»¶è§£æ
                    const parseProgress = document.getElementById('parseProgress');
                    
                    // è·å–ç”¨æˆ·æŒ‡å®šçš„åˆ—åè¡Œå·ï¼ˆè½¬æ¢ä¸º0-basedç´¢å¼•ï¼‰
                    const headerRow = parseInt(document.getElementById('headerRowInput').value) || 11;
                    const headerIndex = headerRow - 1;
                    
                    // 1. å…ˆæ‰¾åˆ°åˆ—åè¡Œï¼ˆä½¿ç”¨indexOfä»£æ›¿splitï¼Œå‡å°‘å†…å­˜å ç”¨ï¼‰
                    let lineCount = 0;
                    let currentPos = 0;
                    let headerLine = '';
                    let dataStartPos = 0;
                    
                    // é€è¡ŒæŸ¥æ‰¾åˆ—åè¡Œ
                    while (currentPos < rawData.length && lineCount <= headerIndex) {
                        const nextNewline = rawData.indexOf('\n', currentPos);
                        if (nextNewline === -1) break;
                        
                        if (lineCount === headerIndex) {
                            // æ‰¾åˆ°äº†åˆ—åè¡Œ
                            headerLine = rawData.substring(currentPos, nextNewline).trim();
                            dataStartPos = nextNewline + 1;
                        }
                        
                        currentPos = nextNewline + 1;
                        lineCount++;
                    }
                    
                    if (!headerLine) {
                        throw new Error(`ç¬¬${headerRow}è¡Œä¸ºç©ºæˆ–æ–‡ä»¶è¡Œæ•°ä¸è¶³ï¼Œæ— æ³•è§£æåˆ—å`);
                    }

                    // è§£æåˆ—åï¼ˆç©ºæ ¼åˆ†éš”ï¼‰
                    columnNames = headerLine.split(/\s+/).filter(v => v && v.trim());
                    
                    if (columnNames.length === 0) {
                        throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„åˆ—å');
                    }

                    // 2. è®¡ç®—æ€»è¡Œæ•°ï¼ˆç”¨äºè¿›åº¦æ˜¾ç¤ºï¼‰
                    let totalLines = 0;
                    let tempPos = dataStartPos;
                    while (tempPos < rawData.length) {
                        const nextNewline = rawData.indexOf('\n', tempPos);
                        if (nextNewline === -1) break;
                        totalLines++;
                        tempPos = nextNewline + 1;
                    }
                    
                    // 3. è§£ææ•°æ®è¡Œï¼ˆä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹å¼ï¼‰
                    parsedData = [];
                    let processedLines = 0;
                    let lastProgressUpdate = 0;
                    
                    currentPos = dataStartPos;
                    while (currentPos < rawData.length) {
                        const nextNewline = rawData.indexOf('\n', currentPos);
                        if (nextNewline === -1) break;
                        
                        const line = rawData.substring(currentPos, nextNewline).trim();
                        currentPos = nextNewline + 1;
                        
                        if (!line || line.startsWith('#')) continue;
                        
                        // è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Šè¡Œ
                        if (line.length < 5) continue;
                        
                        // ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹å¼åˆ†å‰²å­—æ®µ
                        const values = [];
                        let start = 0;
                        for (let i = 0; i <= line.length; i++) {
                            if (i === line.length || /\s/.test(line[i])) {
                                if (i > start) {
                                    const val = line.substring(start, i).trim();
                                    if (val) values.push(val);
                                }
                                start = i + 1;
                            }
                        }
                        
                        if (values.length >= columnNames.length * 0.8) {
                            const row = {};
                            let hasValidData = false;
                            
                            columnNames.forEach((col, idx) => {
                                if (idx < values.length) {
                                    const val = values[idx];
                                    const numVal = parseFloat(val);
                                    if (!isNaN(numVal)) {
                                        row[col] = numVal;
                                        hasValidData = true;
                                    } else {
                                        row[col] = val || null;
                                    }
                                } else {
                                    row[col] = null;
                                }
                            });
                            
                            if (hasValidData) {
                                parsedData.push(row);
                            }
                        }
                        
                        processedLines++;
                        
                        // æ›´æ–°è¿›åº¦ï¼ˆæ¯å¤„ç†1000è¡Œæ›´æ–°ä¸€æ¬¡ï¼Œé¿å…é¢‘ç¹DOMæ“ä½œï¼‰
                        if (processedLines % 1000 === 0 || processedLines === totalLines) {
                            const progress = Math.round((processedLines / totalLines) * 100);
                            if (progress > lastProgressUpdate) {
                                parseProgress.textContent = `æ­£åœ¨è§£ææ•°æ®... ${progress}% (${processedLines}/${totalLines}è¡Œ)`;
                                lastProgressUpdate = progress;
                            }
                        }
                    }

                    // æ˜¾ç¤ºåˆ—ååˆ—è¡¨
                    displayColumnList();

                    console.log('æ–‡ä»¶åŠ è½½æˆåŠŸ:', {
                        æ–‡ä»¶å: fileName,
                        åˆ—æ•°: columnNames.length,
                        æ•°æ®è¡Œæ•°: parsedData.length,
                        æ€»å¤„ç†è¡Œæ•°: processedLines
                    });

                } catch (error) {
                    console.error('åŠ è½½æ–‡ä»¶å¤±è´¥:', error);
                    columnList.innerHTML = `<div class="error">åŠ è½½å¤±è´¥: ${error.message}</div>`;
                }
            }, 0);
        }

        // åŠ è½½Excelæ–‡ä»¶æ•°æ®
        function loadXlsxData(arrayBuffer, fileName) {
            const columnList = document.getElementById('columnList');
            columnList.innerHTML = '<div class="loading">æ­£åœ¨è§£æExcelæ–‡ä»¶...<br><div id="parseProgress" style="margin-top: 10px; font-size: 14px; color: #666;">å‡†å¤‡è§£æ...</div></div>';

            // ä½¿ç”¨setTimeoutå°†è§£æä»»åŠ¡æ”¾å…¥äº‹ä»¶é˜Ÿåˆ—ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
            setTimeout(() => {
                try {
                    const parseProgress = document.getElementById('parseProgress');
                    
                    // ä½¿ç”¨XLSXåº“è§£æExcelæ–‡ä»¶
                    parseProgress.textContent = 'æ­£åœ¨è¯»å–Excelæ–‡ä»¶...';
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    
                    // è·å–ç¬¬ä¸€ä¸ªå·¥ä½œè¡¨
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // è½¬æ¢ä¸ºJSONæ ¼å¼
                    parseProgress.textContent = 'æ­£åœ¨è½¬æ¢æ•°æ®æ ¼å¼...';
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    // è·å–ç”¨æˆ·æŒ‡å®šçš„åˆ—åè¡Œå·ï¼ˆè½¬æ¢ä¸º0-basedç´¢å¼•ï¼‰
                    const headerRow = parseInt(document.getElementById('headerRowInput').value) || 1;
                    const headerIndex = headerRow - 1;
                    
                    if (jsonData.length < headerRow) {
                        throw new Error(`Excelæ–‡ä»¶è¡Œæ•°ä¸è¶³ï¼Œæ— æ³•è·å–ç¬¬${headerRow}è¡Œçš„åˆ—å`);
                    }

                    // è·å–åˆ—å
                    const headerRowData = jsonData[headerIndex];
                    columnNames = headerRowData.filter(v => v && v.toString().trim()).map(v => v.toString().trim());
                    
                    if (columnNames.length === 0) {
                        throw new Error('æœªæ‰¾åˆ°æœ‰æ•ˆçš„åˆ—å');
                    }

                    // è§£ææ•°æ®ï¼ˆä»åˆ—åè¡Œçš„ä¸‹ä¸€è¡Œå¼€å§‹ï¼‰
                    parsedData = [];
                    const dataStartLine = headerIndex + 1;
                    const totalRows = jsonData.length - dataStartLine;
                    
                    parseProgress.textContent = 'æ­£åœ¨è§£ææ•°æ®... 0%';
                    
                    // åˆ†æ‰¹å¤„ç†æ•°æ®
                    const batchSize = 5000;
                    for (let batchStart = dataStartLine; batchStart < jsonData.length; batchStart += batchSize) {
                        const batchEnd = Math.min(batchStart + batchSize, jsonData.length);
                        
                        for (let i = batchStart; i < batchEnd; i++) {
                            const row = jsonData[i];
                            if (!row || row.length === 0) continue;

                            const rowData = {};
                            let hasValidData = false;
                            
                            columnNames.forEach((col, idx) => {
                                if (idx < row.length) {
                                    const val = row[idx];
                                    if (val !== null && val !== undefined) {
                                        const numVal = parseFloat(val);
                                        if (!isNaN(numVal)) {
                                            rowData[col] = numVal;
                                            hasValidData = true;
                                        } else {
                                            rowData[col] = val;
                                        }
                                    } else {
                                        rowData[col] = null;
                                    }
                                } else {
                                    rowData[col] = null;
                                }
                            });
                            
                            if (hasValidData) {
                                parsedData.push(rowData);
                            }
                        }
                        
                        // æ›´æ–°è¿›åº¦
                        const processed = batchEnd - dataStartLine;
                        const progress = Math.round((processed / totalRows) * 100);
                        parseProgress.textContent = `æ­£åœ¨è§£ææ•°æ®... ${progress}%`;
                    }

                    // æ˜¾ç¤ºåˆ—ååˆ—è¡¨
                    displayColumnList();

                    console.log('Excelæ–‡ä»¶åŠ è½½æˆåŠŸ:', {
                        æ–‡ä»¶å: fileName,
                        å·¥ä½œè¡¨: firstSheetName,
                        åˆ—æ•°: columnNames.length,
                        æ•°æ®è¡Œæ•°: parsedData.length
                    });

                } catch (error) {
                    console.error('åŠ è½½Excelæ–‡ä»¶å¤±è´¥:', error);
                    columnList.innerHTML = `<div class="error">ExcelåŠ è½½å¤±è´¥: ${error.message}</div>`;
                }
            }, 0);
        }

        // æ˜¾ç¤ºåˆ—ååˆ—è¡¨
        function displayColumnList() {
            const columnList = document.getElementById('columnList');
            columnList.innerHTML = '';

            columnNames.forEach((col, index) => {
                const item = document.createElement('div');
                item.className = 'column-item';
                item.textContent = `${index + 1}. ${col}`;
                item.onclick = (e) => selectColumn(col, item, e);
                item.title = 'ç‚¹å‡»é€‰æ‹© | Ctrl+ç‚¹å‡»å¤šé€‰';
                columnList.appendChild(item);
            });
        }

        // é€‰æ‹©åˆ—ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
        function selectColumn(columnName, element, event) {
            // å¦‚æœæŒ‰ä½Ctrlæˆ–Cmdé”®ï¼Œåˆ™å¤šé€‰
            if (event && (event.ctrlKey || event.metaKey)) {
                // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
                element.classList.toggle('selected');
                
                // æ›´æ–°activeç±»ï¼šå¦‚æœè¯¥åˆ—è¢«é€‰ä¸­ï¼Œæ·»åŠ activeï¼›å¦åˆ™ç§»é™¤
                if (element.classList.contains('selected')) {
                    element.classList.add('active');
                    // è‡ªåŠ¨åˆ†é…Yè½´ï¼šå¦‚æœæ˜¯ç¬¬ä¸€ä¸ªé€‰ä¸­çš„åˆ—ï¼Œä½¿ç”¨ä¸»Yè½´ï¼›å¦åˆ™äº¤æ›¿ä½¿ç”¨Yè½´
                    const selectedItems = document.querySelectorAll('.column-item.selected');
                    const axis = selectedItems.length % 2 === 0 ? 'y2' : 'y1'; // è‡ªåŠ¨äº¤æ›¿åˆ†é…Yè½´
                    addChart(columnName, axis);
                } else {
                    element.classList.remove('active');
                    removeChartByColumn(columnName);
                }
                
                // æ›´æ–°æ ‡é¢˜ï¼Œæ˜¾ç¤ºé€‰ä¸­çš„åˆ—æ•°
                const selectedItems = document.querySelectorAll('.column-item.selected');
                document.getElementById('selectedColumnName').textContent = `ğŸ“ˆ å·²é€‰æ‹© ${selectedItems.length} åˆ—`;
            } else {
                // å•é€‰æ¨¡å¼ï¼šæ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.column-item').forEach(item => {
                    item.classList.remove('active', 'selected');
                });
                element.classList.add('active');
                currentSelectedColumn = columnName;

                // æ›´æ–°æ ‡é¢˜
                document.getElementById('selectedColumnName').textContent = `ğŸ“ˆ ${columnName} - æ•°æ®åˆ†æ`;

                // æ˜¾ç¤ºæ•°æ®åˆ†æå’Œå›¾è¡¨ï¼ˆdisplayAnalysiså†…éƒ¨ä¼šè‡ªåŠ¨æ·»åŠ å›¾è¡¨ï¼‰
                displayAnalysis(columnName);
            }
        }

        // æ ¹æ®åˆ—åç§»é™¤å›¾è¡¨
        function removeChartByColumn(columnName) {
            const chart = activeCharts.find(c => c.columnName === columnName);
            if (chart) {
                removeChart(chart.id);
            }
        }

        // æ·»åŠ æ–°å›¾è¡¨
        function addNewChart() {
            if (!parsedData || parsedData.length === 0) {
                alert('è¯·å…ˆåŠ è½½æ–‡ä»¶å¹¶é€‰æ‹©åˆ—');
                return;
            }

            // åˆ›å»ºæ¨¡æ€å¯¹è¯æ¡†
            const modal = document.createElement('div');
            modal.className = 'add-chart-modal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;';
            
            const dialog = document.createElement('div');
            dialog.className = 'add-chart-dialog';
            dialog.style.cssText = 'background: white; padding: 30px; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); min-width: 400px;';
            
            // åˆ›å»ºé€‰æ‹©æ¡†
            const select = document.createElement('select');
            select.id = 'columnSelectDialog';
            select.style.cssText = 'width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 5px; font-size: 1em; margin-bottom: 20px;';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'è¯·é€‰æ‹©åˆ—...';
            select.appendChild(defaultOption);
            columnNames.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;
                select.appendChild(option);
            });
            
            // åˆ›å»ºæŒ‰é’®
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'å–æ¶ˆ';
            cancelBtn.style.cssText = 'padding: 10px 20px; background: #f0f0f0; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;';
            cancelBtn.onclick = () => {
                modal.remove();
            };
            
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'ç¡®å®š';
            confirmBtn.style.cssText = 'padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;';
            confirmBtn.onclick = () => {
                const columnName = select.value;
                if (!columnName) {
                    alert('è¯·é€‰æ‹©ä¸€ä¸ªåˆ—');
                    return;
                }
                // æ·»åŠ å›¾è¡¨
                addChart(columnName);
                // å…³é—­æ¨¡æ€æ¡†
                modal.remove();
            };
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';
            buttonContainer.appendChild(cancelBtn);
            buttonContainer.appendChild(confirmBtn);
            
            dialog.innerHTML = '<h3 style="margin-bottom: 20px; color: #667eea;">é€‰æ‹©è¦æ·»åŠ çš„åˆ—</h3>';
            dialog.appendChild(select);
            dialog.appendChild(buttonContainer);
            
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­ï¼ˆä½†ä¸è¦å…³é—­å¯¹è¯æ¡†æœ¬èº«ï¼‰
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            // é˜»æ­¢å¯¹è¯æ¡†å†…çš„ç‚¹å‡»äº‹ä»¶å†’æ³¡
            dialog.onclick = (e) => {
                e.stopPropagation();
            };
        }

        // æ·»åŠ å›¾è¡¨ï¼ˆæ”¯æŒä¸»åæ ‡è½´å’Œæ¬¡åæ ‡è½´ï¼‰
        function addChart(columnName, axis = 'y1') {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥åˆ—çš„å›¾è¡¨
            const existingChart = activeCharts.find(c => c.columnName === columnName);
            if (existingChart) {
                // å¦‚æœå·²å­˜åœ¨ï¼Œé‡æ–°ç»˜åˆ¶
                drawChartForColumn(columnName, existingChart.id);
                return;
            }

            // æ–°å»ºå›¾è¡¨
            chartCounter++;
            const newChartId = `chart_${chartCounter}`;
            
            const chartsContainer = document.getElementById('chartsContainer');
            const chartDiv = document.createElement('div');
            chartDiv.className = 'chart-container';
            chartDiv.id = newChartId;
            
            chartDiv.innerHTML = `
                <div class="chart-header">
                    <h4>å›¾${chartCounter}: ${columnName}</h4>
                    <div class="chart-actions">
                        <button onclick="showSelectColumnsDialog('${newChartId}')" class="axis-button" style="margin-right: 10px; padding: 6px 12px; font-size: 13px; background: #28a745; color: white;">é€‰æ‹©åˆ—</button>
                        <button class="chart-close" onclick="removeChart('${newChartId}')">Ã—</button>
                    </div>
                </div>
                <div class="chart-controls">
                    <div class="chart-controls-row">
                        <div class="axis-control-group">
                            <div class="axis-control">
                                <label>æ•°æ®ç‚¹èŒƒå›´:</label>
                                <input type="number" id="${newChartId}_startPoint" placeholder="èµ·å§‹ç‚¹" step="1" class="axis-input">
                                <span class="axis-separator">-</span>
                                <input type="number" id="${newChartId}_endPoint" placeholder="ç»“æŸç‚¹" step="1" class="axis-input">
                                <button onclick="updateDataRange('${newChartId}')" class="axis-button">åº”ç”¨</button>
                            </div>
                        </div>
                        <div class="axis-control-group">
                            <div class="axis-control">
                                <label>Xè½´:</label>
                                <input type="number" id="${newChartId}_xMin" placeholder="æœ€å°å€¼" step="1" class="axis-input">
                                <span class="axis-separator">-</span>
                                <input type="number" id="${newChartId}_xMax" placeholder="æœ€å¤§å€¼" step="1" class="axis-input">
                                <button onclick="updateChartAxis('${newChartId}', 'x')" class="axis-button">åº”ç”¨</button>
                            </div>
                        </div>
                        <div class="axis-control-group">
                            <div class="axis-control">
                                <label>ä¸»Yè½´:</label>
                                <input type="number" id="${newChartId}_y1Min" placeholder="æœ€å°å€¼" step="0.01" class="axis-input">
                                <span class="axis-separator">-</span>
                                <input type="number" id="${newChartId}_y1Max" placeholder="æœ€å¤§å€¼" step="0.01" class="axis-input">
                                <button onclick="updateChartAxis('${newChartId}', 'y1')" class="axis-button">åº”ç”¨</button>
                            </div>
                        </div>
                        <div class="axis-control-group">
                            <div class="axis-control">
                                <label>æ¬¡Yè½´:</label>
                                <input type="number" id="${newChartId}_y2Min" placeholder="æœ€å°å€¼" step="0.01" class="axis-input">
                                <span class="axis-separator">-</span>
                                <input type="number" id="${newChartId}_y2Max" placeholder="æœ€å¤§å€¼" step="0.01" class="axis-input">
                                <button onclick="updateChartAxis('${newChartId}', 'y2')" class="axis-button">åº”ç”¨</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="chart-wrapper">
                    <canvas class="chart-canvas" id="${newChartId}_canvas"></canvas>
                </div>
            `;
            
            chartsContainer.appendChild(chartDiv);
            
            // å­˜å‚¨å›¾è¡¨ä¿¡æ¯
            const chartInfo = {
                id: newChartId,
                columnName: columnName,
                chartNumber: chartCounter,
                startPoint: null,
                endPoint: null,
                xMin: null,
                xMax: null,
                y1Min: null,
                y1Max: null,
                y2Min: null,
                y2Max: null,
                axis: axis, // y1: ä¸»Yè½´, y2: æ¬¡Yè½´
                lines: [ // æ”¯æŒå¤šæ¡çº¿æ¡
                    {
                        columnName: columnName,
                        axis: axis,
                        color: lineColors[chartCounter % lineColors.length], // å¾ªç¯ä½¿ç”¨ä¸åŒé¢œè‰²
                        visible: true
                    }
                ]
            };
            activeCharts.push(chartInfo);

            // è®¾ç½®åæ ‡è½´é€‰æ‹©
            const axisSelect = document.getElementById(newChartId + '_axisSelect');
            if (axisSelect) {
                axisSelect.value = axis;
            }

            // ç»˜åˆ¶å›¾è¡¨ï¼ˆå»¶è¿Ÿä»¥ç¡®ä¿DOMå®Œå…¨æ¸²æŸ“ï¼‰
            setTimeout(() => {
                const canvas = document.getElementById(newChartId + '_canvas');
                if (canvas) {
                    drawChartForColumn(columnName, newChartId);
                } else {
                    console.error('Canvaså…ƒç´ æœªæ‰¾åˆ°:', newChartId + '_canvas');
                    // é‡è¯•ä¸€æ¬¡
                    setTimeout(() => {
                        drawChartForColumn(columnName, newChartId);
                    }, 200);
                }
            }, 150);
        }

        // æ˜¾ç¤ºé€‰æ‹©åˆ—å¯¹è¯æ¡†
        function showSelectColumnsDialog(chartId) {
            const chart = activeCharts.find(c => c.id === chartId);
            if (!chart) return;

            // åˆ›å»ºæ¨¡æ€å¯¹è¯æ¡†
            const modal = document.createElement('div');
            modal.className = 'select-columns-modal';
            modal.style.cssText = `
                position: fixed; 
                top: 0; 
                left: 0; 
                width: 100%; 
                height: 100%; 
                background: rgba(0,0,0,0.5); 
                z-index: 10000; 
                display: flex; 
                align-items: center; 
                justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; 
                padding: 20px; 
                border-radius: 10px; 
                box-shadow: 0 10px 40px rgba(0,0,0,0.3); 
                width: 500px; 
                max-height: 80vh;
                display: flex;
                flex-direction: column;
            `;
            
            // å¯¹è¯æ¡†æ ‡é¢˜
            const title = document.createElement('h3');
            title.textContent = 'é€‰æ‹©è¦æ˜¾ç¤ºçš„åˆ—ï¼ˆå¯å¤šé€‰ï¼‰';
            title.style.cssText = `
                margin-bottom: 20px; 
                color: #333; 
                font-size: 18px;
                text-align: center;
                border-bottom: 2px solid #667eea;
                padding-bottom: 10px;
            `;
            dialog.appendChild(title);
            
            // åˆ—é€‰æ‹©åŒºåŸŸ
            const columnsContainer = document.createElement('div');
            columnsContainer.style.cssText = `
                flex: 1;
                overflow-y: auto;
                margin-bottom: 20px;
                padding: 10px;
                background: #f8f9fa;
                border-radius: 8px;
                max-height: 400px;
            `;
            
            // åˆ›å»ºåˆ—é€‰æ‹©é¡¹
                columnNames.forEach((col, index) => {
                    const isSelected = chart.lines.some(line => line.columnName === col);
                    const line = chart.lines.find(line => line.columnName === col);
                    const currentColor = line ? line.color : lineColors[index % lineColors.length];
                    const currentAxis = line ? line.axis : (index % 2 === 0 ? 'y1' : 'y2'); // è‡ªåŠ¨åˆ†é…Yè½´
                    
                    const columnItem = document.createElement('div');
                    columnItem.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 15px;
                        padding: 10px;
                        margin-bottom: 8px;
                        background: white;
                        border-radius: 6px;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    `;
                    
                    // å¤é€‰æ¡†
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `col_${index}`;
                    checkbox.checked = isSelected;
                    checkbox.style.cssText = 'width: 18px; height: 18px;';
                    
                    // åˆ—å
                    const label = document.createElement('label');
                    label.htmlFor = `col_${index}`;
                    label.textContent = col;
                    label.style.cssText = 'flex: 1; font-size: 14px;';
                    
                    // Yè½´é€‰æ‹©
                    const axisSelect = document.createElement('select');
                    axisSelect.className = 'axis-select';
                    axisSelect.style.cssText = 'width: 100px; padding: 5px; border: 1px solid #ddd; border-radius: 3px; font-size: 14px;';
                    
                    const axisOptions = [
                        { value: 'y1', text: 'ä¸»Yè½´' },
                        { value: 'y2', text: 'æ¬¡Yè½´' }
                    ];
                    
                    axisOptions.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.text;
                        if (opt.value === currentAxis) {
                            option.selected = true;
                        }
                        axisSelect.appendChild(option);
                    });
                    
                    // é¢œè‰²é€‰æ‹©å™¨
                    const colorPicker = document.createElement('input');
                    colorPicker.type = 'color';
                    colorPicker.value = currentColor;
                    colorPicker.style.cssText = 'width: 40px; height: 30px; border: none; border-radius: 4px; cursor: pointer;';
                    
                    columnItem.appendChild(checkbox);
                    columnItem.appendChild(label);
                    columnItem.appendChild(axisSelect);
                    columnItem.appendChild(colorPicker);
                    columnsContainer.appendChild(columnItem);
                });
            
            dialog.appendChild(columnsContainer);
            
            // æŒ‰é’®åŒºåŸŸ
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.cssText = `
                display: flex;
                gap: 15px;
                justify-content: flex-end;
                padding-top: 15px;
                border-top: 1px solid #e0e0e0;
            `;
            
            // å–æ¶ˆæŒ‰é’®
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'å–æ¶ˆ';
            cancelBtn.style.cssText = `
                padding: 10px 20px;
                background: #f0f0f0;
                color: #333;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 600;
                transition: background-color 0.3s;
            `;
            cancelBtn.onclick = () => modal.remove();
            cancelBtn.onmouseover = () => cancelBtn.style.backgroundColor = '#e0e0e0';
            cancelBtn.onmouseout = () => cancelBtn.style.backgroundColor = '#f0f0f0';
            
            // ç¡®å®šæŒ‰é’®
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'ç¡®å®š';
            confirmBtn.style.cssText = `
                padding: 10px 20px;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                font-weight: 600;
                transition: background-color 0.3s;
            `;
            confirmBtn.onclick = () => {
                // å¤„ç†ç”¨æˆ·é€‰æ‹©
                const selectedLines = [];
                const columnItems = columnsContainer.querySelectorAll('div');
                
                let yAxisIndex = 0;
                columnItems.forEach((item, index) => {
                    const checkbox = item.querySelector('input[type="checkbox"]');
                    const colorPicker = item.querySelector('input[type="color"]');
                    const axisSelect = item.querySelector('.axis-select');
                    
                    if (checkbox.checked) {
                        selectedLines.push({
                            columnName: columnNames[index],
                            axis: axisSelect ? axisSelect.value : (yAxisIndex % 2 === 0 ? 'y1' : 'y2'), // è‡ªåŠ¨åˆ†é…Yè½´
                            color: colorPicker.value,
                            visible: true
                        });
                        yAxisIndex++;
                    }
                });
                
                // æ›´æ–°å›¾è¡¨çº¿æ¡é…ç½®
                chart.lines = selectedLines;
                
                // é‡æ–°ç»˜åˆ¶å›¾è¡¨
                drawChartForColumn(chart.columnName, chart.id);
                
                // å…³é—­å¯¹è¯æ¡†
                modal.remove();
            };
            confirmBtn.onmouseover = () => confirmBtn.style.backgroundColor = '#5568d3';
            confirmBtn.onmouseout = () => confirmBtn.style.backgroundColor = '#667eea';
            
            buttonsContainer.appendChild(cancelBtn);
            buttonsContainer.appendChild(confirmBtn);
            dialog.appendChild(buttonsContainer);
            
            modal.appendChild(dialog);
            document.body.appendChild(modal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­å¯¹è¯æ¡†
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
        }

        // æ”¹å˜å›¾è¡¨ä½¿ç”¨çš„åæ ‡è½´
        function changeChartAxis(chartId, axis) {
            const chartInfo = activeCharts.find(c => c.id === chartId);
            if (chartInfo) {
                // æ›´æ–°ä¸»åˆ—çš„åæ ‡è½´
                chartInfo.axis = axis;
                
                // å¦‚æœåªæœ‰ä¸€æ¡çº¿ï¼Œä¹Ÿæ›´æ–°è¯¥çº¿çš„åæ ‡è½´
                if (chartInfo.lines && chartInfo.lines.length === 1) {
                    chartInfo.lines[0].axis = axis;
                }
                
                // é‡æ–°ç»˜åˆ¶å›¾è¡¨
                drawChartForColumn(chartInfo.columnName, chartId);
            }
        }


        // æ›´æ–°æ•°æ®ç‚¹èŒƒå›´
        function updateDataRange(chartId) {
            const chartInfo = activeCharts.find(c => c.id === chartId);
            if (!chartInfo) return;

            const startPointInput = document.getElementById(chartId + '_startPoint');
            const endPointInput = document.getElementById(chartId + '_endPoint');
            const startPoint = startPointInput.value ? parseInt(startPointInput.value) : null;
            const endPoint = endPointInput.value ? parseInt(endPointInput.value) : null;
            
            if (startPoint !== null && endPoint !== null && startPoint >= endPoint) {
                alert('èµ·å§‹ç‚¹å¿…é¡»å°äºç»“æŸç‚¹');
                return;
            }
            
            chartInfo.startPoint = startPoint;
            chartInfo.endPoint = endPoint;

            // é‡æ–°ç»˜åˆ¶å›¾è¡¨
            drawChartForColumn(chartInfo.columnName, chartId);
        }

        // æ›´æ–°å›¾è¡¨åæ ‡è½´
        function updateChartAxis(chartId, axis) {
            const chartInfo = activeCharts.find(c => c.id === chartId);
            if (!chartInfo) return;

            if (axis === 'x') {
                const xMinInput = document.getElementById(chartId + '_xMin');
                const xMaxInput = document.getElementById(chartId + '_xMax');
                const xMin = xMinInput.value ? parseFloat(xMinInput.value) : null;
                const xMax = xMaxInput.value ? parseFloat(xMaxInput.value) : null;
                
                if (xMin !== null && xMax !== null && xMin >= xMax) {
                    alert('Xè½´æœ€å°å€¼å¿…é¡»å°äºæœ€å¤§å€¼');
                    return;
                }
                
                chartInfo.xMin = xMin;
                chartInfo.xMax = xMax;
            } else if (axis === 'y1') {
                const yMinInput = document.getElementById(chartId + '_y1Min');
                const yMaxInput = document.getElementById(chartId + '_y1Max');
                const yMin = yMinInput.value ? parseFloat(yMinInput.value) : null;
                const yMax = yMaxInput.value ? parseFloat(yMaxInput.value) : null;
                
                if (yMin !== null && yMax !== null && yMin >= yMax) {
                    alert('Yè½´æœ€å°å€¼å¿…é¡»å°äºæœ€å¤§å€¼');
                    return;
                }
                
                chartInfo.y1Min = yMin;
                chartInfo.y1Max = yMax;
            } else if (axis === 'y2') {
                const yMinInput = document.getElementById(chartId + '_y2Min');
                const yMaxInput = document.getElementById(chartId + '_y2Max');
                const yMin = yMinInput.value ? parseFloat(yMinInput.value) : null;
                const yMax = yMaxInput.value ? parseFloat(yMaxInput.value) : null;
                
                if (yMin !== null && yMax !== null && yMin >= yMax) {
                    alert('æ¬¡Yè½´æœ€å°å€¼å¿…é¡»å°äºæœ€å¤§å€¼');
                    return;
                }
                
                chartInfo.y2Min = yMin;
                chartInfo.y2Max = yMax;
            }

            // é‡æ–°ç»˜åˆ¶å›¾è¡¨
            drawChartForColumn(chartInfo.columnName, chartId);
        }

        // ç§»é™¤å›¾è¡¨
        function removeChart(chartId) {
            const chartElement = document.getElementById(chartId);
            if (chartElement) {
                chartElement.remove();
                activeCharts = activeCharts.filter(chart => chart.id !== chartId);
            }
        }

        // æ˜¾ç¤ºæ•°æ®åˆ†æ
        function displayAnalysis(columnName) {
            const contentBody = document.getElementById('contentBody');
            
            if (!parsedData || parsedData.length === 0) {
                contentBody.innerHTML = '<div class="error">æ²¡æœ‰æ•°æ®å¯åˆ†æ</div>';
                return;
            }

            // è·å–è¯¥åˆ—çš„æ•°æ®
            const values = parsedData
                .map(row => row[columnName])
                .filter(v => v !== null && v !== undefined && !isNaN(v) && typeof v === 'number');

            if (values.length === 0) {
                contentBody.innerHTML = '<div class="error">è¯¥åˆ—æ²¡æœ‰æœ‰æ•ˆçš„æ•°å€¼æ•°æ®</div>';
                return;
            }

            // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
            const sorted = [...values].sort((a, b) => a - b);
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = sum / values.length;
            const variance = values.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / values.length;
            const std = Math.sqrt(variance);
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            const median = sorted[Math.floor(sorted.length / 2)];
            const q25 = sorted[Math.floor(sorted.length * 0.25)];
            const q75 = sorted[Math.floor(sorted.length * 0.75)];

            // ç”ŸæˆHTML
            let html = `
                <div class="analysis-section">
                    <h3>ğŸ“Š åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="label">æ•°æ®ç‚¹æ•°</div>
                            <div class="value">${values.length.toLocaleString()}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">å¹³å‡å€¼</div>
                            <div class="value">${mean.toFixed(4)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æ ‡å‡†å·®</div>
                            <div class="value">${std.toFixed(4)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æœ€å°å€¼</div>
                            <div class="value">${min.toFixed(4)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æœ€å¤§å€¼</div>
                            <div class="value">${max.toFixed(4)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">ä¸­ä½æ•°</div>
                            <div class="value">${median.toFixed(4)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">25%åˆ†ä½æ•°</div>
                            <div class="value">${q25.toFixed(4)}</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">75%åˆ†ä½æ•°</div>
                            <div class="value">${q75.toFixed(4)}</div>
                        </div>
                    </div>
                </div>

                <div class="chart-section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3>ğŸ“ˆ æŠ˜çº¿å›¾</h3>
                        <button onclick="addNewChart()" style="padding: 8px 15px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9em;">
                            + æ·»åŠ å›¾è¡¨
                        </button>
                    </div>
                    <div class="charts-container" id="chartsContainer">
                        <!-- å›¾è¡¨å°†åŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
                    </div>
                </div>
            `;

            contentBody.innerHTML = html;

            // ç­‰å¾…DOMæ›´æ–°å®Œæˆåå†æ“ä½œ
            setTimeout(() => {
                // æ¸…ç©ºä¹‹å‰çš„å›¾è¡¨
                const chartsContainer = document.getElementById('chartsContainer');
                if (chartsContainer) {
                    chartsContainer.innerHTML = '';
                }
                activeCharts = [];
                chartCounter = 0;

                // æ·»åŠ ç¬¬ä¸€ä¸ªå›¾è¡¨
                addChart(columnName);
            }, 50);
        }

        // ä¸ºæŒ‡å®šåˆ—ç»˜åˆ¶å›¾è¡¨
        function drawChartForColumn(columnName, chartId) {
            if (!parsedData || parsedData.length === 0) {
                console.warn('æ²¡æœ‰æ•°æ®å¯ç»˜åˆ¶');
                return;
            }

            const canvas = document.getElementById(chartId + '_canvas');
            if (!canvas) {
                console.error('Canvaså…ƒç´ æœªæ‰¾åˆ°:', chartId + '_canvas');
                return;
            }

            // è·å–å›¾è¡¨ä¿¡æ¯
            const chartInfo = activeCharts.find(c => c.id === chartId);
            
            // ç»˜åˆ¶æŠ˜çº¿å›¾ï¼ˆæ”¯æŒå¤šæ¡çº¿ï¼‰
            drawLineChart(columnName, canvas, chartInfo);
        }

        // ç»˜åˆ¶æŠ˜çº¿å›¾ï¼ˆæ”¯æŒå¤šæ¡çº¿ï¼‰
        function drawLineChart(columnName, canvasElement, chartInfo) {
            if (!canvasElement) return;

            // è·å–å®¹å™¨å°ºå¯¸å¹¶è®¾ç½®Canvasåˆ†è¾¨ç‡ï¼ˆè§£å†³æ¨¡ç³Šé—®é¢˜ï¼‰
            const container = canvasElement.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = 500;
            
            // è®¾ç½®Canvaså®é™…å°ºå¯¸ï¼ˆé«˜åˆ†è¾¨ç‡ï¼‰
            const devicePixelRatio = window.devicePixelRatio || 1;
            canvasElement.width = containerWidth * devicePixelRatio;
            canvasElement.height = containerHeight * devicePixelRatio;
            canvasElement.style.width = containerWidth + 'px';
            canvasElement.style.height = containerHeight + 'px';

            const ctx = canvasElement.getContext('2d');
            ctx.scale(devicePixelRatio, devicePixelRatio);

            const width = containerWidth;
            const height = containerHeight;
            // å¢åŠ å³ä¾§è¾¹è·ï¼Œä¸ºæ¬¡Yè½´ç•™å‡ºç©ºé—´
            const margin = { top: 50, right: 100, bottom: 80, left: 100 };

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);

            // è·å–æ‰€æœ‰å¯è§çº¿æ¡çš„æ•°æ®
            const visibleLines = chartInfo.lines.filter(line => line.visible);
            if (visibleLines.length === 0) {
                // å¦‚æœæ²¡æœ‰å¯è§çº¿æ¡ï¼Œæ˜¾ç¤ºæç¤º
                ctx.fillStyle = '#999';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ²¡æœ‰å¯è§çš„æ•°æ®çº¿', width / 2, height / 2);
                return;
            }

            // å‡†å¤‡æ‰€æœ‰æ•°æ®ï¼Œç”¨äºè®¡ç®—åæ ‡è½´èŒƒå›´
            let allValues = [];
            const lineData = {};
            
            // æ”¶é›†æ‰€æœ‰å¯è§çº¿æ¡çš„æ•°æ®
            visibleLines.forEach(line => {
                const values = parsedData
                    .map(row => row[line.columnName])
                    .filter(v => v !== null && v !== undefined && !isNaN(v) && typeof v === 'number');
                
                lineData[line.columnName] = values;
                allValues = allValues.concat(values);
            });

            // è®¡ç®—æ•°æ®èŒƒå›´ï¼ˆè€ƒè™‘è‡ªå®šä¹‰èŒƒå›´ï¼‰
            let minValue = Math.min(...allValues);
            let maxValue = Math.max(...allValues);
            
            // è®¡ç®—æ•°æ®ç‚¹èŒƒå›´ï¼ˆè€ƒè™‘è‡ªå®šä¹‰èŒƒå›´ï¼‰
            let dataStart = 0;
            let dataEnd = Math.max(...Object.values(lineData).map(data => data.length - 1));
            
            // åº”ç”¨æ•°æ®ç‚¹èŒƒå›´è¿‡æ»¤
            if (chartInfo) {
                if (chartInfo.startPoint !== null) {
                    dataStart = Math.max(0, chartInfo.startPoint - 1);
                }
                if (chartInfo.endPoint !== null) {
                    dataEnd = Math.min(dataEnd, chartInfo.endPoint - 1);
                }
            }
            
            // è®¡ç®—Xè½´èŒƒå›´ï¼ˆè€ƒè™‘è‡ªå®šä¹‰èŒƒå›´ï¼‰
            let xMin = dataStart;
            let xMax = dataEnd;
            
            if (chartInfo) {
                if (chartInfo.xMin !== null) xMin = Math.max(xMin, Math.min(chartInfo.xMin - 1, xMax));
                if (chartInfo.xMax !== null) xMax = Math.min(xMax, Math.max(chartInfo.xMax - 1, xMin));
                if (chartInfo.xMin !== null && chartInfo.xMax !== null) {
                    xMin = Math.max(dataStart, chartInfo.xMin - 1);
                    xMax = Math.min(dataEnd, chartInfo.xMax - 1);
                }
            }
            
            // è¿‡æ»¤æ•°æ®ï¼ˆæ ¹æ®Xè½´èŒƒå›´ï¼‰
            Object.keys(lineData).forEach(column => {
                lineData[column] = lineData[column].slice(xMin, xMax + 1);
            });

            // ç¼©æ”¾å‡½æ•°
            // Xè½´ï¼šç´¢å¼•ä»0å¼€å§‹ï¼Œå¯¹åº”æ•°ç»„ç´¢å¼•
            const xScale = (index) => {
                const maxLength = Math.max(...Object.values(lineData).map(data => data.length - 1));
                if (maxLength <= 1) return margin.left;
                return margin.left + (index / maxLength) * (width - margin.left - margin.right);
            };
            
            // Yè½´ï¼šæ•°å€¼æ˜ å°„ï¼ˆä¸»Yè½´ï¼‰
            const yScaleY1 = (value) => {
                // ä½¿ç”¨ä¸»Yè½´èŒƒå›´
                let y1Min = minValue;
                let y1Max = maxValue;
                if (chartInfo && chartInfo.y1Min !== null && chartInfo.y1Max !== null) {
                    y1Min = chartInfo.y1Min;
                    y1Max = chartInfo.y1Max;
                }
                const y1Range = y1Max - y1Min;
                const y1Padding = y1Range < 0.1 ? y1Range * 0.2 : (y1Range > 100 ? y1Range * 0.05 : y1Range * 0.1);
                const range = y1Range + y1Padding * 2;
                if (range === 0) return margin.top + (height - margin.top - margin.bottom) / 2;
                return margin.top + (height - margin.top - margin.bottom) - ((value - y1Min + y1Padding) / range) * (height - margin.top - margin.bottom);
            };
            
            // Yè½´ï¼šæ•°å€¼æ˜ å°„ï¼ˆæ¬¡Yè½´ï¼‰
            const yScaleY2 = (value) => {
                // ä½¿ç”¨æ¬¡Yè½´èŒƒå›´
                let y2Min = minValue;
                let y2Max = maxValue;
                if (chartInfo && chartInfo.y2Min !== null && chartInfo.y2Max !== null) {
                    y2Min = chartInfo.y2Min;
                    y2Max = chartInfo.y2Max;
                }
                const y2Range = y2Max - y2Min;
                const y2Padding = y2Range < 0.1 ? y2Range * 0.2 : (y2Range > 100 ? y2Range * 0.05 : y2Range * 0.1);
                const range = y2Range + y2Padding * 2;
                if (range === 0) return margin.top + (height - margin.top - margin.bottom) / 2;
                return margin.top + (height - margin.top - margin.bottom) - ((value - y2Min + y2Padding) / range) * (height - margin.top - margin.bottom);
            };

            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(margin.left, margin.top, width - margin.left - margin.right, height - margin.top - margin.bottom);

            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + ((height - margin.top - margin.bottom) / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(width - margin.right, y);
                ctx.stroke();
            }

            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºæ¬¡Yè½´
            const hasMultipleYAxes = visibleLines.some(line => line.axis === 'y2');
            
            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, height - margin.bottom);
            ctx.lineTo(width - margin.right, height - margin.bottom);
            ctx.stroke();
            
            // å¦‚æœæœ‰æ¬¡Yè½´ï¼Œç»˜åˆ¶æ¬¡Yè½´
            if (hasMultipleYAxes) {
                ctx.beginPath();
                ctx.moveTo(width - margin.right, margin.top);
                ctx.lineTo(width - margin.right, height - margin.bottom);
                ctx.stroke();
            }

            // ç»˜åˆ¶Xè½´åˆ»åº¦å’Œæ ‡ç­¾
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            const xTickCount = 10;
            const maxLength = Math.max(...Object.values(lineData).map(data => data.length - 1));
            
            for (let i = 0; i <= xTickCount; i++) {
                const x = margin.left + (i / xTickCount) * (width - margin.left - margin.right);
                // Xè½´æ˜¾ç¤ºå®é™…çš„æ•°æ®ç‚¹ç´¢å¼•ï¼ˆä»1å¼€å§‹ï¼Œå¯¹åº”åŸå§‹æ•°æ®è¡Œå·ï¼‰
                const relativeIndex = Math.round((i / xTickCount) * maxLength);
                const value = xMin + relativeIndex + 1;
                
                // ç»˜åˆ¶åˆ»åº¦çº¿
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, height - margin.bottom);
                ctx.lineTo(x, height - margin.bottom + 5);
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾ï¼ˆæ ¼å¼åŒ–å¤§æ•°å­—ï¼‰
                const label = value >= 1000 ? (value / 1000).toFixed(1) + 'k' : value.toString();
                ctx.fillText(label, x, height - margin.bottom + 8);
            }
            
            // Xè½´æ ‡é¢˜
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('æ•°æ®ç‚¹ç´¢å¼•', margin.left + (width - margin.left - margin.right) / 2, height - 20);

            // ç»˜åˆ¶Yè½´åˆ»åº¦å’Œæ ‡ç­¾ï¼ˆä¸»Yè½´ï¼‰
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const yTickCount = 10;
            let y1Min = minValue;
            let y1Max = maxValue;
            if (chartInfo && chartInfo.y1Min !== null && chartInfo.y1Max !== null) {
                y1Min = chartInfo.y1Min;
                y1Max = chartInfo.y1Max;
            }
            const y1Range = y1Max - y1Min;
            const y1Padding = y1Range < 0.1 ? y1Range * 0.2 : (y1Range > 100 ? y1Range * 0.05 : y1Range * 0.1);
            
            for (let i = 0; i <= yTickCount; i++) {
                const y = margin.top + (i / yTickCount) * (height - margin.top - margin.bottom);
                // Yè½´ä»æœ€å¤§å€¼åˆ°æœ€å°å€¼
                const value = y1Max + y1Padding - (i / yTickCount) * (y1Range + y1Padding * 2);
                
                // ç»˜åˆ¶åˆ»åº¦çº¿
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left - 5, y);
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾ï¼ˆæ ¹æ®æ•°å€¼èŒƒå›´å†³å®šå°æ•°ä½æ•°ï¼‰
                let label;
                if (Math.abs(value) < 0.01) {
                    label = value.toFixed(4);
                } else if (Math.abs(value) < 1) {
                    label = value.toFixed(3);
                } else if (Math.abs(value) < 100) {
                    label = value.toFixed(2);
                } else {
                    label = value.toFixed(1);
                }
                ctx.fillText(label, margin.left - 10, y);
            }
            
            // Yè½´æ ‡é¢˜
            ctx.save();
            ctx.translate(15, margin.top + (height - margin.top - margin.bottom) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ä¸»Yè½´æ•°å€¼', 0, 0);
            ctx.restore();
            
            // ç»˜åˆ¶æ¬¡Yè½´åˆ»åº¦å’Œæ ‡ç­¾ï¼ˆå¦‚æœæœ‰æ¬¡Yè½´ï¼‰
            if (hasMultipleYAxes) {
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                const yTickCount = 10;
                let y2Min = minValue;
                let y2Max = maxValue;
                if (chartInfo && chartInfo.y2Min !== null && chartInfo.y2Max !== null) {
                    y2Min = chartInfo.y2Min;
                    y2Max = chartInfo.y2Max;
                }
                const y2Range = y2Max - y2Min;
                const y2Padding = y2Range < 0.1 ? y2Range * 0.2 : (y2Range > 100 ? y2Range * 0.05 : y2Range * 0.1);
                
                for (let i = 0; i <= yTickCount; i++) {
                    const y = margin.top + ((height - margin.top - margin.bottom) / 10) * i;
                    // æ¬¡Yè½´ä»æœ€å¤§å€¼åˆ°æœ€å°å€¼
                    const value = y2Max + y2Padding - (i / yTickCount) * (y2Range + y2Padding * 2);
                    
                    // ç»˜åˆ¶åˆ»åº¦çº¿
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(width - margin.right, y);
                    ctx.lineTo(width - margin.right + 5, y);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶æ ‡ç­¾ï¼ˆæ ¹æ®æ•°å€¼èŒƒå›´å†³å®šå°æ•°ä½æ•°ï¼‰
                    let label;
                    if (Math.abs(value) < 0.01) {
                        label = value.toFixed(4);
                    } else if (Math.abs(value) < 1) {
                        label = value.toFixed(3);
                    } else if (Math.abs(value) < 100) {
                        label = value.toFixed(2);
                    } else {
                        label = value.toFixed(1);
                    }
                    ctx.fillText(label, width - margin.right + 10, y);
                }
                
                // æ¬¡Yè½´æ ‡é¢˜
                ctx.save();
                ctx.translate(width - 15, margin.top + (height - margin.top - margin.bottom) / 2);
                ctx.rotate(Math.PI / 2);
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ¬¡Yè½´æ•°å€¼', 0, 0);
                ctx.restore();
            }

            // ç»˜åˆ¶æ‰€æœ‰å¯è§çš„æ•°æ®çº¿
            visibleLines.forEach(line => {
                const values = lineData[line.columnName];
                if (!values || values.length === 0) return;

                // é€‰æ‹©å¯¹åº”çš„Yè½´ç¼©æ”¾å‡½æ•°
                const yScale = line.axis === 'y1' ? yScaleY1 : yScaleY2;

                // ç»˜åˆ¶æŠ˜çº¿
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 2.5;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();

                // å¦‚æœæ•°æ®ç‚¹å¤ªå¤šï¼Œåªç»˜åˆ¶å…³é”®ç‚¹ä»¥æé«˜æ€§èƒ½
                const drawEveryN = values.length > 10000 ? Math.ceil(values.length / 5000) : 1;
                
                values.forEach((value, index) => {
                    if (index % drawEveryN === 0 || index === values.length - 1) {
                        const x = xScale(index);
                        const y = yScale(value);
                        
                        if (index === 0 || (index % drawEveryN === 0 && index > 0)) {
                            ctx.lineTo(x, y);
                        } else {
                            ctx.moveTo(x, y);
                        }
                    }
                });

                ctx.stroke();

                // å¦‚æœæ•°æ®ç‚¹ä¸å¤ªå¤šï¼Œç»˜åˆ¶æ•°æ®ç‚¹
                if (values.length <= 500) {
                    ctx.fillStyle = line.color;
                    values.forEach((value, index) => {
                        if (index % Math.max(1, Math.floor(values.length / 100)) === 0) {
                            const x = xScale(index);
                            const y = yScale(value);
                            ctx.beginPath();
                            ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                }
            });

            // ç»˜åˆ¶å›¾ä¾‹
            drawLegend(ctx, visibleLines, margin.left, margin.top - 40, width - margin.left - margin.right);

            // ç»˜åˆ¶æ ‡é¢˜
            ctx.fillStyle = '#667eea';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('æ•°æ®å¯¹æ¯”', margin.left + (width - margin.left - margin.right) / 2, 25);
        }

        // ç»˜åˆ¶å›¾ä¾‹
        function drawLegend(ctx, lines, x, y, width) {
            const legendItemHeight = 20;
            const legendItemMargin = 15;
            
            let currentX = x;
            let currentY = y;
            
            lines.forEach((line, index) => {
                const itemWidth = ctx.measureText(line.columnName).width + 25;
                
                // å¦‚æœè¶…è¿‡å®½åº¦ï¼Œæ¢è¡Œ
                if (currentX + itemWidth > x + width - 10) {
                    currentX = x;
                    currentY += legendItemHeight + 5;
                }
                
                // ç»˜åˆ¶é¢œè‰²æ–¹å—
                ctx.fillStyle = line.color;
                ctx.fillRect(currentX, currentY + 3, 15, 15);
                
                // ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = '#555';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.columnName, currentX + 20, currentY + 10.5);
                
                currentX += itemWidth + legendItemMargin;
            });
        }

        // é¡µé¢åŠ è½½æ—¶å°è¯•è‡ªåŠ¨åŠ è½½æ–‡ä»¶
        window.addEventListener('load', () => {
            // å¯ä»¥åœ¨è¿™é‡Œè®¾ç½®é»˜è®¤æ–‡ä»¶
            // loadFile();
        });
    </script>
</body>
</html>
